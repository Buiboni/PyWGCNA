corFormals = formals(corFnc)
if ("nThreads" %in% names(corFormals))
corOptions$nThreads = 1
datk = matrix(0, nrow = nGenes, ncol = length(powerVector))
nThreads = WGCNAnThreads()
nPowers = length(powerVector)
startG = 1
lastGC = 0
corOptions$x = data
if (!is.null(weights)) {
if (!dataIsExpr)
stop("Weights can only be used when 'data' represents expression data ('dataIsExpr' must be TRUE).")
if (!isTRUE(all.equal(dim(data), dim(weights))))
stop("When 'weights' are given, dimensions of 'data' and 'weights' must be the same.")
corOptions$weights.x = weights
}
while (startG <= nGenes) {
endG = min(startG + blockSize - 1, nGenes)
if (verbose > 1)
printFlush(paste(spaces, "  ..working on genes",
startG, "through", endG, "of", nGenes))
nBlockGenes = endG - startG + 1
jobs = allocateJobs(nBlockGenes, nThreads)
actualThreads = which(sapply(jobs, length) > 0)
datk[c(startG:endG), ] = foreach(t = actualThreads,
.combine = rbind) %dopar% {
useGenes = c(startG:endG)[jobs[[t]]]
nGenes1 = length(useGenes)
if (dataIsExpr) {
corOptions$y = data[, useGenes]
if (!is.null(weights))
corOptions$weights.y = weights[, useGenes]
corx = do.call(corFnc, corOptions)
if (intType == 1) {
corx = abs(corx)
}
else if (intType == 2) {
corx = (1 + corx)/2
}
else if (intType == 3) {
corx[corx < 0] = 0
}
if (sum(is.na(corx)) != 0)
warning(paste("Some correlations are NA in block",
startG, ":", endG, "."))
}
else {
corx = data[, useGenes]
}
ind = cbind(useGenes, 1:length(useGenes))
corx[ind] = 1
datk.local = matrix(NA, nGenes1, nPowers)
corxPrev = matrix(1, nrow = nrow(corx), ncol = ncol(corx))
powerVector1 <- c(0, head(powerVector, -1))
powerSteps <- powerVector - powerVector1
uniquePowerSteps <- unique(powerSteps)
corxPowers <- lapply(uniquePowerSteps, function(p) corx^p)
names(corxPowers) <- uniquePowerSteps
for (j in 1:nPowers) {
corxCur <- corxPrev * corxPowers[[as.character(powerSteps[j])]]
datk.local[, j] = colSums(corxCur, na.rm = TRUE) -
1
corxPrev <- corxCur
}
datk.local
}
startG = endG + 1
if ((gcInterval > 0) && (startG - lastGC > gcInterval)) {
gc()
lastGC = startG
}
if (verbose == 1)
pind = updateProgInd(endG/nGenes, pind)
}
library(dynamicTreeCut)
library("doSNOW")
library("doParallel")
library("doMPI")
while (startG <= nGenes) {
endG = min(startG + blockSize - 1, nGenes)
if (verbose > 1)
printFlush(paste(spaces, "  ..working on genes",
startG, "through", endG, "of", nGenes))
nBlockGenes = endG - startG + 1
jobs = allocateJobs(nBlockGenes, nThreads)
actualThreads = which(sapply(jobs, length) > 0)
datk[c(startG:endG), ] = foreach(t = actualThreads,
.combine = rbind) %dopar% {
useGenes = c(startG:endG)[jobs[[t]]]
nGenes1 = length(useGenes)
if (dataIsExpr) {
corOptions$y = data[, useGenes]
if (!is.null(weights))
corOptions$weights.y = weights[, useGenes]
corx = do.call(corFnc, corOptions)
if (intType == 1) {
corx = abs(corx)
}
else if (intType == 2) {
corx = (1 + corx)/2
}
else if (intType == 3) {
corx[corx < 0] = 0
}
if (sum(is.na(corx)) != 0)
warning(paste("Some correlations are NA in block",
startG, ":", endG, "."))
}
else {
corx = data[, useGenes]
}
ind = cbind(useGenes, 1:length(useGenes))
corx[ind] = 1
datk.local = matrix(NA, nGenes1, nPowers)
corxPrev = matrix(1, nrow = nrow(corx), ncol = ncol(corx))
powerVector1 <- c(0, head(powerVector, -1))
powerSteps <- powerVector - powerVector1
uniquePowerSteps <- unique(powerSteps)
corxPowers <- lapply(uniquePowerSteps, function(p) corx^p)
names(corxPowers) <- uniquePowerSteps
for (j in 1:nPowers) {
corxCur <- corxPrev * corxPowers[[as.character(powerSteps[j])]]
datk.local[, j] = colSums(corxCur, na.rm = TRUE) -
1
corxPrev <- corxCur
}
datk.local
}
startG = endG + 1
if ((gcInterval > 0) && (startG - lastGC > gcInterval)) {
gc()
lastGC = startG
}
if (verbose == 1)
pind = updateProgInd(endG/nGenes, pind)
}
endG = min(startG + blockSize - 1, nGenes)
if (verbose > 1)
printFlush(paste(spaces, "  ..working on genes",
startG, "through", endG, "of", nGenes))
nBlockGenes = endG - startG + 1
jobs = allocateJobs(nBlockGenes, nThreads)
actualThreads = which(sapply(jobs, length) > 0)
datk[c(startG:endG), ] = foreach(t = actualThreads,
.combine = rbind) %dopar% {
useGenes = c(startG:endG)[jobs[[t]]]
nGenes1 = length(useGenes)
if (dataIsExpr) {
corOptions$y = data[, useGenes]
if (!is.null(weights))
corOptions$weights.y = weights[, useGenes]
corx = do.call(corFnc, corOptions)
if (intType == 1) {
corx = abs(corx)
}
else if (intType == 2) {
corx = (1 + corx)/2
}
else if (intType == 3) {
corx[corx < 0] = 0
}
if (sum(is.na(corx)) != 0)
warning(paste("Some correlations are NA in block",
startG, ":", endG, "."))
}
else {
corx = data[, useGenes]
}
ind = cbind(useGenes, 1:length(useGenes))
corx[ind] = 1
datk.local = matrix(NA, nGenes1, nPowers)
corxPrev = matrix(1, nrow = nrow(corx), ncol = ncol(corx))
powerVector1 <- c(0, head(powerVector, -1))
powerSteps <- powerVector - powerVector1
uniquePowerSteps <- unique(powerSteps)
corxPowers <- lapply(uniquePowerSteps, function(p) corx^p)
names(corxPowers) <- uniquePowerSteps
for (j in 1:nPowers) {
corxCur <- corxPrev * corxPowers[[as.character(powerSteps[j])]]
datk.local[, j] = colSums(corxCur, na.rm = TRUE) -
1
corxPrev <- corxCur
}
datk.local
}
t = actualThreads
useGenes = c(startG:endG)[jobs[[t]]]
nGenes1 = length(useGenes)
if (dataIsExpr) {
corOptions$y = data[, useGenes]
if (!is.null(weights))
corOptions$weights.y = weights[, useGenes]
corx = do.call(corFnc, corOptions)
if (intType == 1) {
corx = abs(corx)
}
else if (intType == 2) {
corx = (1 + corx)/2
}
else if (intType == 3) {
corx[corx < 0] = 0
}
if (sum(is.na(corx)) != 0)
warning(paste("Some correlations are NA in block",
startG, ":", endG, "."))
}
View(corOptions)
View(corOptions)
# Call the network topology analysis function
sft = pickSoftThreshold(data, powerVector = powers, verbose = 5, networkType = "signed")
# Call the network topology analysis function
sft = pickSoftThreshold(data, powerVector = powerVector, verbose = 5, networkType = "signed")
warnings()
View(datk)
View(datk)
dim(datk)
dim(data)
View(data)
View(data)
data = read.csv("../output/data/data_input", row.names = 1)
View(data)
View(data)
# Choose a set of soft-thresholding powers
powerVector = c(c(1:10), seq(from = 11, to=19, by=2))
# Call the network topology analysis function
sft = pickSoftThreshold(data, powerVector = powerVector, verbose = 5, networkType = "signed")
View(datk)
View(datk)
nBreaks = 10
a = = cut(datk[, 1], nBreaks)
b = datk[, 1]
a = = cut(b, nBreaks)
a = cut(b, nBreaks)
a
x  <- seq(1,10,1)
cut(x, breaks = seq(0,10,2), labels = c('A','B','C','D','E'))
x
seq(0,10,2)
b = cut(x, breaks = seq(0,10,2), labels = c('A','B','C','D','E'))
k = datk[, 1]
discretized.k = cut(k, nBreaks)
dk = tapply(k, discretized.k, mean)
p.dk = as.vector(tapply(k, discretized.k, length)/length(k))
discretized.k
seq(from = min(k), to = max(k), length = nBreaks +
1)
seq(from = 1.2, to = 3.5, length = nBreaks +
1)
data = read.csv("../output/data/data_input", row.names = 1)
# Choose a set of soft-thresholding powers
powerVector = c(c(1:10), seq(from = 11, to=19, by=2))
### picksoftthereshold
dataIsExpr = TRUE
weights = NULL
RsquaredCut = 0.85
removeFirst = FALSE
nBreaks = 10
blockSize = NULL
corFnc = cor
corOptions = list(use = "p")
networkType = "signed"
moreNetworkConcepts = FALSE
gcInterval = NULL
verbose = 5
indent = 0
.networkTypes = c("unsigned", "signed", "signed hybrid")
####correlation
method = "pearson"
weights.x = NULL
weights.y = NULL
quick = 0
cosine = FALSE
cosineX = cosine
cosineY = cosine
drop = FALSE
library(WGCNA)
library(RColorBrewer)
library(cowplot)
library(Hmisc)
library("ComplexHeatmap")
ht_opt$message = FALSE
library(stringr)
options(stringsAsFactors = FALSE);
library('analyze.stuff')
library(dynamicTreeCut)
library("doSNOW")
library("doParallel")
library("doMPI")
powerVector = sort(powerVector)
intType = charmatch(networkType, .networkTypes)
if (is.na(intType))
stop(paste("Unrecognized 'networkType'. Recognized values are",
paste(.networkTypes, collapse = ", ")))
nGenes = ncol(data)
if (nGenes < 3) {
stop("The input data data contain fewer than 3 rows (nodes).",
"\nThis would result in a trivial correlation network.")
}
if (!dataIsExpr) {
checkSimilarity(data)
if (any(diag(data) != 1))
diag(data) = 1
}
if (is.null(blockSize)) {
blockSize = blockSize(nGenes, rectangularBlocks = TRUE,
maxMemoryAllocation = 2^30)
if (verbose > 0)
printFlush(spaste("pickSoftThreshold: will use block size ",
blockSize, "."))
}
if (length(gcInterval) == 0)
gcInterval = 4 * blockSize
colname1 = c("Power", "SFT.R.sq", "slope", "truncated R.sq",
"mean(k)", "median(k)", "max(k)")
if (moreNetworkConcepts) {
colname1 = c(colname1, "Density", "Centralization",
"Heterogeneity")
}
datout = data.frame(matrix(666, nrow = length(powerVector),
ncol = length(colname1)))
names(datout) = colname1
datout[, 1] = powerVector
spaces = indentSpaces(indent)
if (verbose > 0) {
cat(paste(spaces, "pickSoftThreshold: calculating connectivity for given powers..."))
if (verbose == 1)
pind = initProgInd()
else cat("\n")
}
corFnc = match.fun(corFnc)
corFormals = formals(corFnc)
if ("nThreads" %in% names(corFormals))
corOptions$nThreads = 1
datk = matrix(0, nrow = nGenes, ncol = length(powerVector))
nThreads = WGCNAnThreads()
nPowers = length(powerVector)
startG = 1
lastGC = 0
corOptions$x = data
if (!is.null(weights)) {
if (!dataIsExpr)
stop("Weights can only be used when 'data' represents expression data ('dataIsExpr' must be TRUE).")
if (!isTRUE(all.equal(dim(data), dim(weights))))
stop("When 'weights' are given, dimensions of 'data' and 'weights' must be the same.")
corOptions$weights.x = weights
}
while (startG <= nGenes) {
endG = min(startG + blockSize - 1, nGenes)
if (verbose > 1)
printFlush(paste(spaces, "  ..working on genes",
startG, "through", endG, "of", nGenes))
nBlockGenes = endG - startG + 1
jobs = allocateJobs(nBlockGenes, nThreads)
actualThreads = which(sapply(jobs, length) > 0)
datk[c(startG:endG), ] = foreach(t = actualThreads,
.combine = rbind) %dopar% {
useGenes = c(startG:endG)[jobs[[t]]]
nGenes1 = length(useGenes)
if (dataIsExpr) {
corOptions$y = data[, useGenes]
if (!is.null(weights))
corOptions$weights.y = weights[, useGenes]
corx = do.call(corFnc, corOptions)
if (intType == 1) {
corx = abs(corx)
}
else if (intType == 2) {
corx = (1 + corx)/2
}
else if (intType == 3) {
corx[corx < 0] = 0
}
if (sum(is.na(corx)) != 0)
warning(paste("Some correlations are NA in block",
startG, ":", endG, "."))
}
else {
corx = data[, useGenes]
}
ind = cbind(useGenes, 1:length(useGenes))
corx[ind] = 1
datk.local = matrix(NA, nGenes1, nPowers)
corxPrev = matrix(1, nrow = nrow(corx), ncol = ncol(corx))
powerVector1 <- c(0, head(powerVector, -1))
powerSteps <- powerVector - powerVector1
uniquePowerSteps <- unique(powerSteps)
corxPowers <- lapply(uniquePowerSteps, function(p) corx^p)
names(corxPowers) <- uniquePowerSteps
for (j in 1:nPowers) {
corxCur <- corxPrev * corxPowers[[as.character(powerSteps[j])]]
datk.local[, j] = colSums(corxCur, na.rm = TRUE) -
1
corxPrev <- corxCur
}
datk.local
}
startG = endG + 1
if ((gcInterval > 0) && (startG - lastGC > gcInterval)) {
gc()
lastGC = startG
}
if (verbose == 1)
pind = updateProgInd(endG/nGenes, pind)
}
if (verbose == 1)
printFlush("")
length(powerVector)
i=1
khelp = datk[, i]
View(datk)
View(datk)
dim(datk)
k = khelp
discretized.k = cut(k, nBreaks)
discretized.k
length(k)
dk = tapply(k, discretized.k, mean)
dk
discretized.k
dk
p.dk
e
p.dk = as.vector(tapply(k, discretized.k, length)/length(k))
p.dk
tapply(k, discretized.k, length)
length(k)
min(k)
max(k)
is.na(dk)
discretized.k = cut(k, nBreaks)
dk = tapply(k, discretized.k, mean)
p.dk = as.vector(tapply(k, discretized.k, length)/length(k))
breaks1 = seq(from = min(k), to = max(k), length = nBreaks +
1)
hist1 = hist(k, breaks = breaks1, plot = FALSE, right = TRUE)
dk2 = hist1$mids
dk
is.na(dk)
dk = ifelse(is.na(dk), dk2, dk)
dk
dk2
dk == 0
dk = ifelse(dk == 0, dk2, dk)
dk
is.na(p.dk)
p.dk
p.dk = ifelse(is.na(p.dk), 0, p.dk)
p.dk
dk2
breaks1
log.dk = as.vector(log10(dk))
if (removeFirst) {
p.dk = p.dk[-1]
log.dk = log.dk[-1]
}
log.p.dk = as.numeric(log10(p.dk + 1e-09))
lm1 = try(lm(log.p.dk ~ log.dk))
if (inherits(lm1, "try-error"))
browser()
lm2 = lm(log.p.dk ~ log.dk + I(10^log.dk))
datout = data.frame(Rsquared.SFT = summary(lm1)$r.squared,
slope.SFT = summary(lm1)$coefficients[2, 1], truncatedExponentialAdjRsquared = summary(lm2)$adj.r.squared)
datout
summary(lm1)$coefficients
SFT1 = scaleFreeFitIndex(k = khelp, nBreaks = nBreaks,
removeFirst = removeFirst)
library(WGCNA)
SFT1 = scaleFreeFitIndex(k = khelp, nBreaks = nBreaks,
removeFirst = removeFirst)
for (i in c(1:length(powerVector))) {
khelp = datk[, i]
if (any(khelp < 0))
browser()
SFT1 = scaleFreeFitIndex(k = khelp, nBreaks = nBreaks,
removeFirst = removeFirst)
datout[i, 2] = SFT1$Rsquared.SFT
datout[i, 3] = SFT1$slope.SFT
datout[i, 4] = SFT1$truncatedExponentialAdjRsquared
datout[i, 5] = mean(khelp, na.rm = TRUE)
datout[i, 6] = median(khelp, na.rm = TRUE)
datout[i, 7] = max(khelp, na.rm = TRUE)
if (moreNetworkConcepts) {
Density = sum(khelp)/(nGenes * (nGenes - 1))
datout[i, 8] = Density
Centralization = nGenes * (max(khelp) - mean(khelp))/((nGenes -
1) * (nGenes - 2))
datout[i, 9] = Centralization
Heterogeneity = sqrt(nGenes * sum(khelp^2)/sum(khelp)^2 -
1)
datout[i, 10] = Heterogeneity
}
}
View(datout)
View(datout)
print(signif(data.frame(datout), 3))
dim(datout)
ind1 = datout[, 2] > RsquaredCut
indcut = NA
indcut = if (sum(ind1) > 0)
min(c(1:length(ind1))[ind1])
else indcut
indcut = NA
indcut = if (sum(ind1) > 0)
min(c(1:length(ind1))[ind1])
else indcut
sum(ind1) > 0
indcut = NA
indcut = if (sum(ind1) > 0)
min(c(1:length(ind1))[ind1])
indcut
powerVector[indcut][[1]]
powerVector[indcut]
